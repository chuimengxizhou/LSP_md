##                                              一、基础实验



#### 1.实验1

##### 1.1实验内容

​		输入一个整数，分别用无符号方式、八进制方式、十六进制方式输出。

##### 1.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	int n;
    printf("输入一个十进制整数：");
	scanf_s("%d", &n);
	printf("无符号型：%u\n八进制：%o\n十六进制：%x", n, n, n);
	return 0;
}
```



##### 1.3实验结果

![image-20210711164723256](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210711164723256.png)

##### 1.4调试心得

​		d格式：用来输出十进制整数。o格式：以无符号八进制形式输出整数。x格式：以无符号十六进制形式输出整数。u格式：以无符号十进制形式输出整数。c格式：输出一个字符。s格式：用来输出一个串。f格式：用来输出实数（包括单、双精度），以小数形式输出。e格式：以指数形式输出实数。g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。

​		而且调试时要注意：格式符的个数要与变量、常量或者表达式的个数一一对应。







#### 2.实验2

##### 2.1实验内容

​		输入2个电阻值，求它们并联和串联的电阻值，输出结果保留2位小数。

##### 2.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	printf("请输入两个电阻值（单位 Ω）：");
	double n, m;
	scanf_s("%lf, %lf", &n, &m);
	printf("并联后阻值：%.2lf Ω；串联后阻值：%.2lf Ω",(m * n / (m + n)),m + n);
	return 0;
}
```



##### 2.3实验结果

![image-20210707162705057](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707162705057.png)

##### 2.4调试心得

​		编程是一门实践性的学科，如果不动手“敲”代码的话，永远都学不会编程。很多问题只有在“敲代码”的时候才能发现。我在学习编程的时候从来都不会刻意记忆什么注意点，这些知识点都是在不停“敲代码”的过程中，自然而然地融入我的身体中的。







#### 3.实验3

##### 3.1实验内容

​		输入两个整数给变量a和b，然后输出a和b，在交换a和b中的值后，再输出a和b，验证两个变量中的数值是否正确地进行了交换。

##### 3.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	printf("分别输入a，b的值：");
	int a, b;
	scanf_s("%d,%d", &a, &b);
	printf("此时,a=%d，b=%d\n", a, b);
	a = a + b;
	b = a - b;
	a = a - b;
	printf("交换后，a=%d，b=%d", a, b);
	return 0;
}
```



##### 3.3实验结果

![image-20210707163304932](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707163304932.png)

##### 3.4调试心得

​		学习了如何使用断点来调试程序，设置了断点，就可以观察程序的运行情况了，其中很重要的一点就是查看相关变量的值，这足以发现大部分逻辑错误。







#### 4.实验4

##### 4.1实验内容

​		输入一个double类型的数，使该数保留小数点后两位，对第三位小数进行四舍五入处理，然后输出此数，以便验证处理是否正确。

##### 4.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	double a, b;
	int m;
    printf("请输入一个double类型的数：");
	scanf_s("%lf", &a);
	m = a * 1000;
	b = m % 10;
	if (b <= 4)
	{
		m -= b;
	}
	else
	{
		m += (10 - b);
	}
	printf("四舍五入后,a=%.3lf", (double)m / 1000);
	return 0;
}
```



##### 4.3实验结果

![image-20210711164929913](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210711164929913.png)

##### 4.4调试心得

​		这个程序的实现思路是将double型扩大1000倍，取出特定位判断后进行更改，再缩小1000倍得以输出。

​		像是一些特定的算法，需要我们加深对他的记忆，以便于在以后的日子里游刃有余地使用。







#### 5.实验5

##### 5.1实验内容

​		编写程序，根据输入的学生成绩，给出相应的等级。90分以上的等级为A，60分以下的等级为E，其余每10分一个等级。

##### 5.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	double m;
	printf("请输入学生成绩：");
	scanf_s("%lf", &m);
	printf("等级：");
	if (m >= 90)
	{
		printf("A");
	}
	else if(m >= 80)
	{
		printf("B");
	}
	else if(m >= 70)
	{
		printf("C");
	}
	else if (m >= 60)
	{
		printf("D");
	}
	else
	{
		printf("E");
	}
	return 0;
}
```



##### 5.3实验结果

![image-20210707182531302](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707182531302.png)

##### 5.4调试心得

​		本次程序的思路是使用if--else多分支结构对输入的数字进行判断，再输出对应的等第。

​		当然也可以使用switch结构，两者都能实现功能。

​		同时，对于多个if 并列，程序会遍历所有的 if 条件。最后一个 else 与最后一个 if 配对，两者必有一个为真。对于多个 else if 并列，程序只要找到一个真，就会退出整个 “条件体”，最后一个else 与 前面的任意一个语句 必有一个为真。







#### 6.实验6

##### 6.1实验内容

​		编写程序，将2000年到3000年中所有的闰年年份输出并统计出闰年的总年数，要求每10个闰年放在一行输出。

##### 6.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	int k, i = 0, sum = 0;
	for (k = 2000; k <= 3000; k++)
	{
		if ((k % 4 == 0 && k % 100 != 0) || k % 400 == 0)
		{
			i++;
			sum++;
			printf("%d  ", k);
		}
		if (i == 10)
		{
			i = 0;
			printf("\n");
		}
	}
	printf("\n闰年总数为：%d", sum);
	return 0;
}
```



##### 6.3实验结果

![image-20210707231553556](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707231553556.png)

##### 6.4调试心得

​		本程序在for循环中嵌套了if语句，实现边循环边判断的功能，同时会统计，也利用计数器，每达10个进行换行。

​		有时候，需要根据一些条件来确认是否执行某一操作，从而在复杂情况下做出正确的选择，嵌套循环是个不错的选择。







#### 7.实验7

##### 7.1实验内容

​		求整数3-100中的素数。为了检查某数是否是素数，采用的方法是，从n=3起直到100止，逐个用i=2～n/2去试除n，只要有一个能整除，说明该数不是素数。

##### 7.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int fun(int m)
{
	int a;
	for (a = 2; a <= m / 2; a++)
	{
		if (m % a == 0)
		{
			return 0;
		}
	}
	return 1;
}

void main()
{
	int i;
	printf("3-100中的素数有：");
	for (i = 3; i <= 100; i++)
	{
		if (fun(i) == 1)
		{
			printf("%d  ", i);
		}
	}
}
```



##### 7.3实验结果

![image-20210707185240959](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707185240959.png)

##### 7.4调试心得

​		本实验定义了一个函数，用于判断某数是不是素数，主函数中利用嵌套循环逐个输出3-100间的素数。

​		注意函数中变量的存活期，主要是局部变量和全局变量的区别。

​		函数的返回值类型，也就是函数return的内容的类型，注意如果有多种结束函数途径的话一定要有多个return。







#### 8.实验8

##### 8.1实验内容

​		编写程序，输入圆的半径r和一个整型数k,当k = 1时，计算圆的面积；当 k= 2时，计算圆的周长；当 k = 3时，既要求出圆的面积也要求出圆的周长,要求使用符号常数PI。

##### 8.2源代码

```c
#include<stdio.h>
#include<stdlib.h>
#define PI 3.14159

void main()
{
	double r;
	int k;
	printf("请输入圆的半径r和整数k：");
	scanf_s("%lf,%d", &r, &k);
	switch (k)
	{
	case 3:
		printf("圆的面积为%.3lf，周长为%.3lf", PI * r * r, 2 * PI * r);
		break;
	case 2:
		printf("圆的周长为%.3lf", 2 * PI * r);
		break;
	case 1:
		printf("圆的面积为%.3lf", PI * r * r);
		break;
	}
}
```



##### 8.3实验结果

![image-20210707224948299](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210707224948299.png)

##### 8.4调试心得

​		本程序使用了switch结构，对于输入的k判断再抉择输出哪些信息。

​		总结：

​		1.case值只能是常量且不能重复。

​		2.表达式的值类型支持byte,short,char,int。

​		3.支持省略break,会有case穿透效果。

​		4.default可以省略，支持在任意位置。

​		5.switch语句结束的标志，遇到break,执行到 代码最后一行。







#### 9.实验9

##### 9.1实验内容

​		 从键盘上输入1~9999之间的正整数,程序包含以下代码：

​			·声明一个名字为number的变量。

​			·声明名字分别是position1、position2、position3、position4的short型变量。

​			·输入number的值

​			·将表达式number/1000的值赋给position1。

​			·将表达式number%1000/100的值赋给position2。

​			·将表达式number%100/10的值赋给position3。

​			·将表达式number%10的值赋给position4。

​			·输出position1、position2、position3、position4的值，并提示它们是number中哪个位置上的数字（个、十、百、千 ）

##### 9.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

void main()
{
	int number;
	short position1, position2, position3, position4;
	printf("请输入1-9999的整数：");
	scanf_s("%d", &number);
	position1 = number / 1000;
	position2 = number % 1000 / 100;
	position3 = number % 100 / 10;
	position4 = number % 10;
	printf("千：%d  百：%d  十：%d  个：%d", position1, position2, position3, position4);
}
```



##### 9.3实验结果

![image-20210708145802180](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145802180.png)

##### 9.4调试心得

​		本程序简单的利用一个printf打印一个整数的位，其中利用的便是如何取出某个整数特定的位的思想。







#### 10.实验10

##### 10.1实验内容

​		设有一阶梯，每步跨2阶，最后余1阶；每步跨3阶，最后余2阶；每步跨5阶，最后余4阶；每步跨6阶，最后余5阶；每步跨7阶时，正好到阶梯顶。问共有多少阶梯?

##### 10.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

void main()
{
	int i=1,j;
	while (1)
	{
		j = 7 * i;
		if (j % 6 == 5 && j % 5 == 4)
		{
			if (j % 3 == 2 && j % 2 == 1)
			{
				break;
			}
		}
		i += 1;
	}
	printf("共有%d阶", j);
}
```



##### 10.3实验结果

![image-20210708145726106](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145726106.png)

##### 10.4调试心得

​		本题类似中国剩余定理，本程序使用了穷举的方法，嵌套循环，举出一个值判断是否符合，符合则推出，反之继续下一个。

​		穷举法：通过举出问题所有的可能解来得到真正解。







#### 11.实验11

##### 11.1实验内容

​		验证：任何一个自然数n的立方均可以写成n个连续的奇数之和。

##### 11.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
	printf("请输入一个自然数：");
	int n, m, i, j, k, sum = 0;
	scanf_s("%d", &n);
	if (n == 0)
	{
		printf("0^3 = 0");
		return 0;
	}
	m = n * n * n;
	printf("%d^3 = ", n);
	for (i = 1;; i += 2)
	{
		j = i;
		for (k = 0; k < n; k++)
		{
			sum += j;
			j += 2;
		}
		if (sum != m)
		{
			sum = 0;
		}
		else
		{
			break;
		}
	}
	printf("%d", i);
	for (k = 1; k < n; k++)
	{
		printf("+%d", i + 2 * k);
	}
	return 0;
}
```



##### 11.3实验结果

![image-20210708145646948](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145646948.png)

##### 11.4调试心得

​		本程序类似实验10，都是穷举出答案。

​		穷举搜索法是编程中常用到的一种方法，通常在找不到解决问题的规律时对可能是解的众多候选解按某种顺序进行逐一枚举和检验，并从中找出那些符合要求的候选解作为问题的解。







#### 12.实验12

##### 12.1实验内容

​		用冒泡法对10个整型数按升序进行排序。(冒泡法是使较小的值像空气泡一样逐渐“上浮”到数组的顶部，而较大的值逐渐下沉到数组的底部。)

##### 12.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

void main()
{
	int num[11], i, j, t;
	printf("请输入十个整数：");
	for (i = 0; i < 10; i++)
	{
		scanf_s("%d", num + i);
	}
	for (j = 0; j < 9; j++)
	{
		for (i = 0; i < 9 - j; i++)
		{
			if (num[i] > num[i + 1])
			{
				t = num[i];
				num[i] = num[i + 1];
				num[i + 1] = t;
			}
		}
	}
	printf("升序结果：");
	for (i = 0; i < 10; i++)
	{
		printf("%d  ", num[i]);
	}
}
```



##### 12.3实验结果

![image-20210708145604348](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145604348.png)

##### 12.4调试心得

​		冒泡排序是众多排序方法中最基础的一种，也是最便于理解的一种。

​		嵌套的感想：外层的嵌套就是第几轮比较，一般来说比较(数组长度-1)轮，内部的循环是具体的数比较了，就是涉及到两两去比较了具体需要循环多少次才可以让这一轮里面的数可以两两比较完，就是这一层循环需要考虑的问题。







#### 13.实验13

##### 13.1实验内容

​		输入10位学生的成绩，求出平均分，并输出高于平均分的同学成绩。

##### 13.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

void main()
{
	double num[11], sum = 0;
	int i;
	printf("请输入十个同学成绩：");
	for (i = 0; i < 10; i++)
	{
		scanf_s("%lf", num + i);
		sum += num[i];
	}
	printf("平均分：%.2lf\n高于平均分的同学成绩：", sum / 10);
	for (i = 0; i < 10; i++)
	{
		if (num[i] * 10 > sum)
		{
			printf("%.1lf  ", num[i]);
		}
	}
}
```



##### 13.3实验结果

![image-20210708145457364](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145457364.png)

##### 13.4调试心得

​		本程序使用了循环输入和循环判断嵌套输出，先得到平均数，在把所有成绩和平均数判断，高的话就输出。







#### 14.实验14

##### 14.1实验内容

​		用递归函数编程计算1！+3！+5！+…+n！。

##### 14.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

int jc(int i)
{
	if (i == 1)
	{
		return 1;
	}
	return jc(i - 1) * i;
}

int dg(int n)
{
	if (n == 1)
	{
		return 1;
	}
	return jc(n) + dg(n - 2);
}

void main()
{
	int n;
door:
	printf("请输入一个正奇数：");
	scanf_s("%d", &n);
	printf("1！+ 3！+···+ %d！= ",n);
	if (n % 2 != 0)
	{
		printf("%d", dg(n));
	}
	else
	{
		printf("未输入奇数，请重输\n");
		goto door;
	}
}
```



##### 14.3实验结果

![image-20210708145339040](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708145339040.png)

##### 14.4调试心得

​		本程序使用了两个函数，一个利用递归求阶乘，一个利用递归并调用前一个求结果，主函数中**增添**了判断输入的是否为奇数的功能，若不是则要求重输。

​		用递归解决问题的思路就在于大事化小，把问题一层一层的剖析。







#### 15.实验15

##### 15.1实验内容

​		用结构体对三名学生的学号、姓名、性别、成绩进行输入与输出。

##### 15.2源代码

```c
#include<stdio.h>
#include<stdlib.h>

struct students
{
	char xh[15];
	char name[20];
	char sex[5];
	double grade;
}st[3];

int main()
{
	struct students* p = st;
	int i;
	for (i = 0; i < 3; i++)
	{
		scanf_s("%s", p->xh, sizeof(p->xh));
		scanf_s("%s", p->name, sizeof(p->name));
		scanf_s("%s", p->sex, sizeof(p->sex));
		scanf_s("%lf", &(p->grade));
		p++;
	}
	p = st;
	printf("学生信息如下(学号+姓名+性别+成绩)：\n");
	for (i = 0; i < 3; i++)
	{
		printf("%s  %s  %s  %.2lf\n", p->xh, p->name, p->sex, p->grade);
		p++;
	}
	return 0;
}
```



##### 15.3实验结果

![image-20210708010232864](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210708010232864.png)

##### 15.4调试心得

​		本程序使用结构体和结构体指针综合实现学生信息的输入与输出功能。

​		总结：

​		1.含有指针成员的结构体初始化的时候，必须给指针成员给一个明确的地址。

​		2.当含有指针成员的结构体作为函数参数的时候，通过形参将结构体传入函数，结构体变量中的指针指向的变量变化可以保存，但是一般变量的变化不能保存。如果要保存一般变量的变化，需将函数参数写成引用的类型&。

​		3.可以定义指向结构体的指针，即指针指向的是一个结构体，指针存放的是一结构体的指针。













## 二、**综合设计 推箱子游戏设计**

#### 1.需求分析

##### 1.1 题目要求

​	1、根据上述题目的要求分析系统的功能需求，画出系统的功能模块图和流程图；
​	2、进行系统的详细设计，针对每个功能，选择合适的数据结构，设计必要的计算方
法，分析设计各个功能的程序流程图；
​	3、根据详细设计，完成系统的编码和调试；
​	4、对系统进行功能、可操作性、稳定性测试；
​	5、按照附件 “报告模板”，编写编程实习报告，并在答辩时上交。

##### 1.2 系统功能要求

​	 推箱子游戏是在一个狭小的仓库中，把箱子移动到制定的目标位置。该游戏是通过控制人的走向来移动箱子，箱子只能向前推，不能向后拉，且一次只能推动一个箱子。因此移动前需细心观察地图，稍不小心就会出现箱子无法移动或者通道被堵的情况，所以需要巧妙地利用有限空间和通道。要求如下：
​	1、采用VS或者C Free编写。
​	2、人机操控平台：启动程序后，系统提供给用户一个人机界面，以便用户有效操作游戏。
​	3、创建并绘制地图：推箱子游戏需要创建不同的地图以增加游戏的趣味性。地图大小要求大于等于10*10个符号（特色地图予以加分）。
​	4、选择地图：系统应提供三个及以上不同难度的地图以供用户选择。
​	5、移动操作：本游戏主要通过人或人和箱子的移动来进行的。系统接收用户输入一个字符（按键）来控制人的走向，并且可以在允许的情况下推动箱子。
​	6、移动步数和得分：移动步数是统计从开始游戏到游戏结束（通关）所走的总步数，在游戏过程中这是实时变化的。得分是统计每将一个箱子移动到目的地所获得的分数，只有当把所有箱子移动到指定目标位置后游戏结束（通关）。要求在人机界面显示移动步数和得分。
​	7、游戏操作说明：系统给用户提供地图元素组成、操作规则等信息。（要求在人机界面显示）

#### 2、系统设计

##### 2.1 模块设计（功能模块图（含调用的函数））

![image-20210712101320979](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712101320979.png)

##### 2.2 程序操作流程（功能操作流程图）

![](C:\Users\吹梦到西屿\Desktop\中转文件夹\图1.png)

##### 2.3 系统的实现

```c++
#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<windows.h>

int f;//储存玩家选择的地图
int mapp[20][20];//地图复制品
int steps;//储存步数

//空地0；墙壁1；箱子3；目的地4；人5；箱子+目的地7；人+目的地9
int map[3][20][20] =
{
	//1
	0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
	0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
	0,0,1,0,3,5,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
	0,0,1,0,0,0,3,0,1,0,0,0,0,0,0,0,0,0,0,0,
	0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
	1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
	1,0,4,0,0,0,0,0,4,0,1,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	//2
	0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,0,0,0,0,0,
	0,0,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,
	0,0,0,0,0,0,1,0,0,1,1,1,1,0,1,0,0,0,0,0,
	0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,
	1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,
	1,5,0,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,0,0,
	1,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,
	1,0,3,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,
	1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,
	1,0,0,1,0,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,
	1,1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,
	1,0,0,1,0,0,1,0,3,1,0,0,1,0,1,0,0,0,0,0,
	1,0,0,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,
	1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,4,1,
	1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,
	1,0,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,1,
	1,1,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,
	1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,0,0,0,4,1,
	1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
	//3
	0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,
	0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
	0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,
	0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,4,0,0,0,1,0,0,0,1,5,3,0,0,0,0,0,0,0,1,
	1,1,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,1,3,3,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
	1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,
	1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,
	1,0,0,4,1,1,1,1,1,0,0,0,0,1,4,0,1,0,0,1,
	1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,
	1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
void background_introduce1();//背景开头
void background_introduce2();//背景结尾
void rules();//图例规则介绍
void map_choose();//地图介绍&玩家选择
void show();//生成地图
int checkbox();//检测地图上是否还有未被推完的箱子,若无则返回1，有返回0
int playgame();//玩游戏
void map_copy();//地图复制
void show_steps_scores();//步数，分数显示
void menu();//菜单栏
void writer_intro();//作者信息介绍


int main()
{
	system("color 0B");
door3:
	menu();
	int m;
	scanf_s("%d", &m);
	if (m == 1)
	{
		system("cls");
		system("color 04");
		background_introduce1();
		system("color 0B");
		goto door3;
	}
	else if (m == 2)
	{
		system("cls");
		map_choose();	//玩家选择地图
	door2:
		steps = 0;
		map_copy();
		while (1)
		{
			if (checkbox() == 1)//判断游戏是否结束
			{
				Sleep(3000);
				break;
			}
			show();//出地图
			if (playgame() == 0)//接受按键操作
			{
				system("cls");
				goto door2;
			}
			system("cls");//刷新
		}
		printf("恭喜通关！！！\n");
		show_steps_scores();//步数分数显示
		background_introduce2();
		goto door3;
	}
	else if (m == 3)
	{
		exit(0);
	}
	else if (m == 4)
	{
		writer_intro();
		goto door3;
	}
	else if (m == 5)
	{
		rules();//规则介绍
		goto door3;
	}
	return 0;
}


//步数，分数显示
void show_steps_scores()
{
	printf("您共用步数为%d    得分：", steps);
	if (f == 0)
	{
		if (steps < 70)
		{
			printf("优秀");
		}
		else if (steps < 85)
		{
			printf("良好");
		}
		else
		{
			printf("合格");
		}

	}
	if (f == 1)
	{
		if (steps < 145)
		{
			printf("优秀");
		}
		else if (steps < 165)
		{
			printf("良好");
		}
		else
		{
			printf("合格");
		}
	}
	if (f == 2)
	{
		if (steps < 145)
		{
			printf("优秀");
		}
		else if (steps < 170)
		{
			printf("良好");
		}
		else
		{
			printf("合格");
		}
	}
	printf("\n\n");
}

//地图复制
void map_copy()
{
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			mapp[i][j] = map[f][i][j];
		}
	}
}

//玩游戏
int playgame()
{
	int i, j;
	char fx;
	//定位人的位置
	for (i = 0; i < 20; i++)
	{
		for (j = 0; j < 20; j++)
		{
			if (mapp[i][j] == 5 || mapp[i][j] == 9)
			{
				goto door1;
			}
		}
	}
door1:
	//按键判断
	fx = _getch();//捕获用户按键
	switch (fx)
	{
	case 'w'://向上
	case 'W':
		steps++;
		if (mapp[i - 1][j] == 0 || mapp[i - 1][j] == 4)//空地上走
		{
			mapp[i][j] -= 5;
			mapp[i - 1][j] += 5;
		}
		if (mapp[i - 1][j] == 3 || mapp[i - 1][j] == 7)//推箱子
		{
			if (mapp[i - 2][j] == 0 || mapp[i - 2][j] == 4)
			{
				mapp[i][j] -= 5;
				mapp[i - 1][j] += 2;
				mapp[i - 2][j] += 3;
			}
		}

		break;
	case 'a'://向左
	case 'A':
		steps++;
		if (mapp[i][j - 1] == 0 || mapp[i][j - 1] == 4)//空地上走
		{
			mapp[i][j] -= 5;
			mapp[i][j - 1] += 5;
		}
		if (mapp[i][j - 1] == 3 || mapp[i][j - 1] == 7)//推箱子
		{
			if (mapp[i][j - 2] == 0 || mapp[i][j - 2] == 4)
			{
				mapp[i][j] -= 5;
				mapp[i][j - 1] += 2;
				mapp[i][j - 2] += 3;
			}
		}

		break;
	case 's'://向下
	case 'S':
		steps++;
		if (mapp[i + 1][j] == 0 || mapp[i + 1][j] == 4)//空地上走
		{
			mapp[i][j] -= 5;
			mapp[i + 1][j] += 5;
		}
		if (mapp[i + 1][j] == 3 || mapp[i + 1][j] == 7)//推箱子
		{
			if (mapp[i + 2][j] == 0 || mapp[i + 2][j] == 4)
			{
				mapp[i][j] -= 5;
				mapp[i + 1][j] += 2;
				mapp[i + 2][j] += 3;
			}
		}

		break;
	case 'd'://向右
	case 'D':
		steps++;
		if (mapp[i][j + 1] == 0 || mapp[i][j + 1] == 4)//空地上走
		{
			mapp[i][j] -= 5;
			mapp[i][j + 1] += 5;
		}
		if (mapp[i][j + 1] == 3 || mapp[i][j + 1] == 7)//推箱子
		{
			if (mapp[i][j + 2] == 0 || mapp[i][j + 2] == 4)
			{
				mapp[i][j] -= 5;
				mapp[i][j + 1] += 2;
				mapp[i][j + 2] += 3;
			}
		}
		break;
	case 'R':
	case 'r':
		return 0;
		break;
	default:
		break;
	}
	return 1;
}

//检测地图上是否还有未被推完的箱子,若无则返回1，有返回0
int checkbox()
{
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			if (mapp[i][j] == 3)
			{
				return 0;
			}
		}
	}
	return 1;
}

//生成地图
void show()
{
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 20; j++)
		{
			//绘制地图
			switch (mapp[i][j])
			{
			case 0:
				printf("  ");
				break;
			case 1:
				printf("●");
				break;
			case 3:
				printf("■");
				break;
			case 4:
				printf("☆");
				break;
			case 5:
				printf("♀");
				break;
			case 7:
				printf("★");
				break;
			case 9:
				printf("♀");
				break;
			}
		}
		printf("\n");
	}
	printf("\n步数：%d", steps);
}

//地图介绍&玩家选择
void map_choose()
{
	printf("地图种类&难度：\n");
	printf("1.飞夺泸定桥（容易）\n");
	printf("2.湘江战役（中等）\n");
	printf("3.遵义会议（困难）\n");
	printf("选择你想要的地图(输入序号)：");
	scanf_s("%d", &f);
	f--;
	system("cls");
}

//图例规则介绍
void rules()
{
	system("cls");
	Sleep(300);
	printf("图例：\n");
	printf("♀：小人\n");
	printf("☆：目的地\n");
	printf("■：箱子\n");
	printf("●：墙壁/障碍\n");
	printf("★：箱子+目的地\n");
	printf("其余为空地\n");
	Sleep(600);
	printf("游戏规则：\n");
	printf("1.将所有箱子推到终点获胜\n");
	printf("2.墙壁或障碍无法破坏或穿过\n");
	printf("3.小人一次只能推一个箱子\n");
	printf("4.WSAD：控制移动\n");
	printf("5.R：重新开始本局游戏\n");
	printf("\n\n\n");
	system("pause");
	system("cls");
}

//菜单栏
void menu()
{
	printf("*** 欢迎来到推箱子小游戏！！！\n\n*** 1.背景介\
绍\n*** 2.开始游戏\n*** 3.退出游戏\n*** 4.查看作者简介\n*** 5.规则\
介绍\n\n*** 请输入你想用的功能（序号）：");
}

//背景结尾
void background_introduce2()
{
	Sleep(1100);
	printf("背景介绍：\n");
	if (f == 0)
	{
		printf("飞夺泸定桥，是中国工农红军长征中的一场重要战役\n1935年5月\
29日，中央红军部队在四川省中西部强渡大渡河成功\n沿大渡河东岸北上，主力由安顺场沿\
大渡河西岸北上\n红四团战士在天下大雨的情况下，在崎岖陡峭的山路上跑步前进，一昼夜\
奔袭竟达240里，终于在5月29日凌晨6时许按时到达泸定桥西岸\n第2连连长和22名突击队员\
沿着枪林弹雨和火墙密布的铁索踩着铁链夺下桥头，并与东岸部队合围占领了泸定桥\n打破\
了蒋介石妄图把红军变成第二个石达开的反革命迷梦\n是红军长征中具有战略意义的重大胜利\
之一\n这次胜利体现了红军无限忠于人民革命事业的大无畏精神\n\n\n");
	}
	else if (f == 1)
	{
		printf("1934年11月27日至12月1日\n中央红军在湘江上游广西境内的兴安县\
、全州县、灌阳县，与国民党军苦战五昼夜\n最终从全州、兴安之间强渡湘江，突破了\
国民党军的第四道封锁线\n粉碎了蒋介石围歼中央红军于湘江以东的企图\n但是，中央\
红军也为此付出了极为惨重的代价\n部队指战员和中央机关人员由长征出发时的8万多人\
锐减至3万余人\n\n湘江战役是中央红军突围以来最壮烈、最关键的一仗\n我军与优势之敌\
苦战，终于撕开了敌重兵设防的封锁线\n粉碎了蒋介石围歼红军于湘江以东的企图\n 红\
军虽然突破了第四道封锁线，但付出了巨大的代价\n5军团和在长征前夕成立的少共国\
际师损失过半，8军团损失更为惨重，34师被敌人重重包围\n全体指战员浴血奋战，直到弹\
尽粮绝，绝大部分同志壮烈牺牲\n大量减员，引起了广大干部和战士对王明军事路线的怀\
疑和不满到达了极点，纷纷要求改换领导\n湘江惨胜直接导致在遵义召开中共中央政治\
局扩大会议。史称“遵义会议”\n它是红军四处碰壁身处绝境时召开的\n从此中国革命\
一个杰出人物正式登上历史舞台\n标志着中国红军翻开崭新的一页\n\n\n");
	}
	else if (f == 2)
	{
		printf("遵义会议是1935年1月中共中央政治局在贵州遵义召开的独立自主\
地解决中国革命问题的一次极其重要的扩大会议\n是在红军第五次反“围剿”失败\
和长征初期严重受挫的情况下\n为了纠正博古、王明、李德等人“左”倾领导在军\
事指挥上的错误而召开的\n这次会议是中国共产党第一次独立自主地运用马克思列\
宁主义基本原理解决自己的路线、方针和政策方面问题的会议\n这次会议，在极端危\
急的历史关头，挽救了党，挽救了红军，挽救了中国革命\n在中国共产党和红军的历\
史上，是一个生死攸关的转折点\n\n\n");
	}
	system("pause");
	system("cls");
}

//背景开头
void background_introduce1()
{
	char str1[450] = "1934年10月  第五次反围剿失败后\n\
中央主力红军为摆脱国民党军队的包围追击\n被迫实行战略性转移\n退出中央根据地  进行长征\n\
\n长征是人类历史上的伟大奇迹\n1936年10月  红二、四方面军到达甘肃会宁地区  同红一方面军\
会师\n红军三大主力会师  标志着万里长征的胜利结束\n\n长征这一人类历史上的伟大壮举\n\
留给我们最宝贵的精神财富\n就是中国共产党人和红军将士用生命和热血铸就的\
伟大长征精神\n\n正值建党100周年\n今天我们以“推箱子”游戏为原型\n载以长征路上的事件\n\
缅怀岁月 奋进新征程\n\n\n\n";
	for (int i = 0; i < 450; i++)
	{
		printf("%c", str1[i]);
		Sleep(1);
	}

	system("pause");
	system("cls");
}


//作者简介
void writer_intro()
{
	system("cls");
	printf("作者：蔡杨晨\n创作地点：杭州电子科技大学\n日期：7.11\n\n");
	system("pause");
	system("cls");
}
```



##### 2.4 人机交互的设计技术

```c++
//菜单栏
void menu()
{
	printf("*** 欢迎来到推箱子小游戏！！！\n\n*** 1.背景介\
绍\n*** 2.开始游戏\n*** 3.退出游戏\n*** 4.查看作者简介\n*** 5.规则\
介绍\n\n*** 请输入你想用的功能（序号）：");
}
```



#### 3、系统测试和结论

##### 3.1 人机界面

![image-20210712150736937](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712150736937.png)

##### 3.2 创建并绘制地图

​                                                     ![image-20210712145756317](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712145756317.png)

![image-20210712145851914](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712145851914.png)

![image-20210712145929104](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712145929104.png)

##### 3.3 选择地图（至少三种）

​                                                  ![image-20210712130144295](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712130144295.png)

##### 3.4 游戏界面（含游戏地图、移动步数和游戏得分统计）

​                                                   ![image-20210712130223422](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712130223422.png)

![image-20210712130320143](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712130320143.png)

##### 3.5 操作说明

​                                                   ![image-20210712130354965](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712130354965.png)

#### 4.本次实践环节的心得体会

##### 4.1 编译链接错误及其解决方法

1.

##### ![image-20210712130556623](C:\Users\吹梦到西屿\AppData\Roaming\Typora\typora-user-images\image-20210712130556623.png)

解决方法：将所有scanf替换成scanf_s

2.

**error C2065: 'show();' : undeclared identifier**

解决方法：在main函数前面声明 void show();

3.

**C2143: syntax error : missing ';' before (identifier) 'system("cls");'**

解决方法：在“system("cls");”的上一句末尾添加“  ；”

4.

**error:stray’\274’in program**

解决方法：将中文符号改为英文符号

##### 4.2 小结

​		这几天一直在做推箱子这个游戏，从中学到了许多新的代码，也学到了许多经验。 

​		下面我来说说我学到的一些新函数：

​				system("pause");//等待用户输入任意键后开始

​				Sleep();//定时休眠

​				system("color 0A");//调整窗口颜色

​		再说一下我做推箱子后的感想，我感觉做游戏就想这事在建一座房子，先建立一个框架，框架中的每一个都像是一个小项目，每一个都连接着，搭完框架后就开始了修饰，添加。同时，也从中学到了游戏界面，布局的构造思想和构造方法，以及键盘与代码之间的有效联系，所以这个设计能够学习到的东西还是很多的了。
